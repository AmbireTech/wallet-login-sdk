{"version":3,"file":"login-sdk-web3-react.esm.js","sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/provider.ts","../src/connector.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { JsonRpcProvider, JsonRpcSigner } from '@ethersproject/providers'\nimport { Transaction } from '@ethersproject/transactions'\nimport { ConnectionInfo } from \"@ethersproject/web\";\nimport { Networkish } from '@ethersproject/networks'\n\nexport class AmbireProvider extends JsonRpcProvider {\n    _address: string\n    _sdk: any\n\n    constructor(sdk: any, address: string, url?: ConnectionInfo | string, network?: Networkish) {\n      super(url, network)\n      this._address = address\n      this._sdk = sdk\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n      const signerAddress = addressOrIndex ? addressOrIndex : this._address\n      const signer = super.getSigner(signerAddress)\n      const provider = this\n\n      const handler1 = {\n        get(target: any, prop: any, receiver: any) {\n          if (prop === 'sendTransaction') {\n            const value = target[prop]\n            if (value instanceof Function) {\n              return function (...args: any) {\n                const txn = args.data ? args : args[0]\n                const txnValue = txn.value ? txn.value.toString() : '0'\n\n                provider._sdk.openSendTransaction(txn.to, txnValue, txn.data)\n\n                return new Promise((resolve, reject) => {\n                  provider._sdk.onTxnSent(async (data: any) => {\n                    const hash = data.hash\n\n                    // if the txn is submitted, try to fetch it until success\n                    let fetchedTx = null\n                    let failed = 0\n                    while (fetchedTx === null && failed < 5) {\n                      fetchedTx = await provider.getTransaction(hash)\n                      if (fetchedTx === null) {\n                        await new Promise((r) => setTimeout(r, 1500))\n                        failed++\n                      }\n                    }\n\n                    const response = provider._wrapTransaction(fetchedTx as Transaction, hash)\n                    response.data = txn.data\n                    return resolve(response)\n                  })\n                  provider._sdk.onTxnRejected(() => {\n                    reject({ code: 4001 })\n                  })\n                })\n              }\n            }\n          }\n\n          if (prop === 'connectUnchecked') {\n            const value = target[prop]\n            if (value instanceof Function) {\n              return function () {\n                return new Proxy(signer, handler1)\n              }\n            }\n          }\n\n          if (prop === 'signMessage' || prop === '_legacySignMessage' || prop === '_signTypedData') {\n            const value = target[prop]\n            if (value instanceof Function) {\n              return function (...args: any) {\n                const type =\n                  prop === 'signMessage'\n                    ? 'personal_sign'\n                    : prop === '_legacySignMessage'\n                    ? 'eth_sign'\n                    : 'eth_signTypedData_v4'\n                return provider.handleMsgSign(type, args)\n              }\n            }\n          }\n\n          return Reflect.get(target, prop, receiver)\n        },\n      }\n\n      return new Proxy(signer, handler1)\n    }\n\n    handleMsgSign(type: string, args: any) {\n      const message = args.length === 1 ? args[0] : args\n      this._sdk.openSignMessage(type, message)\n\n      return new Promise((resolve, reject) => {\n        this._sdk.msgSigned(() => {\n          return resolve(args[0])\n        })\n        this._sdk.onMsgRejected(() => {\n          reject({ code: 4001 })\n        })\n      })\n    }\n  }","import { AmbireLoginSDK } from '@ambire/login-sdk-core'\nimport { Actions, Connector } from '@web3-react/types'\nimport { AmbireProvider } from './provider'\n\nexport class AmbireConnector extends Connector {\n    _sdk: any\n\n    constructor(actions: Actions, options: any, onError?: (error: Error) => void) {\n        super(actions, onError)\n        this._sdk = new AmbireLoginSDK(options)\n    }\n\n    activate(chainInfo: any): Promise<void> | void {\n        this.actions.startActivation()\n        this._sdk.openLogin(chainInfo)\n\n        return new Promise((resolve, reject) => {\n            this._sdk.onAlreadyLoggedIn((data: any) => {\n            const activeChainId = chainInfo ? parseInt(chainInfo.chainId) : parseInt(data.chainId)\n            this.customProvider = this.getProvider(data.address, data.providerUrl)\n            this.actions.update({ chainId: activeChainId, accounts: [data.address] })\n            resolve()\n            })\n            this._sdk.onLoginSuccess((data: any) => {\n            const activeChainId = chainInfo ? parseInt(chainInfo.chainId) : parseInt(data.chainId)\n            this.customProvider = this.getProvider(data.address, data.providerUrl)\n            this.actions.update({ chainId: activeChainId, accounts: [data.address] })\n            resolve()\n            })\n            this._sdk.onRegistrationSuccess((data: any) => {\n            const activeChainId = chainInfo ? chainInfo.chainId : data.chainId\n            this.customProvider = this.getProvider(data.address, data.providerUrl)\n            this.actions.update({ chainId: activeChainId, accounts: [data.address] })\n            resolve()\n            })\n            this._sdk.onActionRejected((data: any) => {\n            const activeChainId = parseInt(data.chainId)\n            this.customProvider = this.getProvider(data.address, data.providerUrl)\n            this.actions.update({ chainId: activeChainId, accounts: [data.address] })\n            reject({ code: 4001, message: 'User rejected the request.' })\n            })\n        })\n    }\n\n    deactivate(): Promise<void> | void {\n        this._sdk.openLogout()\n\n        return new Promise((resolve) => {\n            this._sdk.onLogoutSuccess(() => {\n            this.customProvider = null\n            this.actions.resetState()\n            resolve()\n            })\n        })\n    }\n\n    getProvider(address: string, providerUrl: string): AmbireProvider {\n        return new AmbireProvider(this._sdk, address, providerUrl)\n    }\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_for","test","update","body","stage","shouldContinue","updateValue","reject","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","AmbireProvider","JsonRpcProvider","constructor","sdk","address","url","network","_address","_sdk","getSigner","addressOrIndex","signerAddress","signer","provider","handler1","get","target","prop","receiver","Function","args","txn","data","txnValue","toString","openSendTransaction","to","Promise","resolve","onTxnSent","response","_wrapTransaction","fetchedTx","hash","failed","getTransaction","r","setTimeout","onTxnRejected","code","Proxy","type","handleMsgSign","Reflect","message","length","openSignMessage","msgSigned","onMsgRejected","AmbireConnector","Connector","actions","options","onError","AmbireLoginSDK","activate","chainInfo","startActivation","openLogin","onAlreadyLoggedIn","activeChainId","parseInt","chainId","customProvider","getProvider","providerUrl","accounts","onLoginSuccess","onRegistrationSuccess","onActionRejected","deactivate","openLogout","onLogoutSuccess","resetState"],"mappings":";;;;AAAA;AACO,IAAMA,KAAK,gBAAiB,YAAW;EAC7C,SAASA,KAAK,GAAG;EACjBA,KAAK,CAACC,SAAS,CAACC,IAAI,GAAG,UAASC,WAAW,EAAEC,UAAU,EAAE;IACxD,IAAMC,MAAM,GAAG,IAAIL,KAAK,EAAE;IAC1B,IAAMM,KAAK,GAAG,IAAI,CAACC,CAAC;IACpB,IAAID,KAAK,EAAE;MACV,IAAME,QAAQ,GAAGF,KAAK,GAAG,CAAC,GAAGH,WAAW,GAAGC,UAAU;MACrD,IAAII,QAAQ,EAAE;QACb,IAAI;UACHC,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEG,QAAQ,CAAC,IAAI,CAACE,CAAC,CAAC,CAAC;SACpC,CAAC,OAAOC,CAAC,EAAE;UACXF,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEM,CAAC,CAAC;;QAEtB,OAAON,MAAM;OACb,MAAM;QACN,OAAO,IAAI;;;IAGb,IAAI,CAACO,CAAC,GAAG,UAASC,KAAK,EAAE;MACxB,IAAI;QACH,IAAMC,KAAK,GAAGD,KAAK,CAACH,CAAC;QACrB,IAAIG,KAAK,CAACN,CAAC,GAAG,CAAC,EAAE;UAChBE,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEF,WAAW,GAAGA,WAAW,CAACW,KAAK,CAAC,GAAGA,KAAK,CAAC;SAC5D,MAAM,IAAIV,UAAU,EAAE;UACtBK,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAED,UAAU,CAACU,KAAK,CAAC,CAAC;SACrC,MAAM;UACNL,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAES,KAAK,CAAC;;OAE1B,CAAC,OAAOH,CAAC,EAAE;QACXF,OAAO,CAACJ,MAAM,EAAE,CAAC,EAAEM,CAAC,CAAC;;KAEtB;IACD,OAAON,MAAM;GACb;EACD,OAAOL,KAAK;AACb,CAAC,EAAG;;AAEJ;AACO,SAASS,OAAO,CAACM,IAAI,EAAET,KAAK,EAAEQ,KAAK,EAAE;EAC3C,IAAI,CAACC,IAAI,CAACR,CAAC,EAAE;IACZ,IAAIO,KAAK,YAAYd,KAAK,EAAE;MAC3B,IAAIc,KAAK,CAACP,CAAC,EAAE;QACZ,IAAID,KAAK,GAAG,CAAC,EAAE;UACdA,KAAK,GAAGQ,KAAK,CAACP,CAAC;;QAEhBO,KAAK,GAAGA,KAAK,CAACJ,CAAC;OACf,MAAM;QACNI,KAAK,CAACF,CAAC,GAAGH,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAET,KAAK,CAAC;QACzC;;;IAGF,IAAIQ,KAAK,IAAIA,KAAK,CAACZ,IAAI,EAAE;MACxBY,KAAK,CAACZ,IAAI,CAACO,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAET,KAAK,CAAC,EAAEG,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAE,CAAC,CAAC,CAAC;MACxE;;IAEDA,IAAI,CAACR,CAAC,GAAGD,KAAK;IACdS,IAAI,CAACL,CAAC,GAAGI,KAAK;IACd,IAAMG,QAAQ,GAAGF,IAAI,CAACH,CAAC;IACvB,IAAIK,QAAQ,EAAE;MACbA,QAAQ,CAACF,IAAI,CAAC;;;AAGjB;AAEO,SAASG,cAAc,CAACC,QAAQ,EAAE;EACxC,OAAOA,QAAQ,YAAYnB,KAAK,IAAImB,QAAQ,CAACZ,CAAC,GAAG,CAAC;AACnD;AAiGO,IAAMa,eAAe,gBAAiB,OAAOC,MAAM,KAAK,WAAW,GAAIA,MAAM,CAACC,QAAQ,KAAKD,MAAM,CAACC,QAAQ,gBAAGD,MAAM,CAAC,iBAAiB,CAAC,CAAC,GAAI,YAAY;AA6DvJ,IAAME,oBAAoB,gBAAiB,OAAOF,MAAM,KAAK,WAAW,GAAIA,MAAM,CAACG,aAAa,KAAKH,MAAM,CAACG,aAAa,gBAAGH,MAAM,CAAC,sBAAsB,CAAC,CAAC,GAAI,iBAAiB;;AA6BvL;AACO,SAASI,IAAI,CAACC,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxC,IAAIC,KAAK;EACT,SAAS;IACR,IAAIC,cAAc,GAAGJ,IAAI,EAAE;IAC3B,IAAIR,cAAc,CAACY,cAAc,CAAC,EAAE;MACnCA,cAAc,GAAGA,cAAc,CAACpB,CAAC;;IAElC,IAAI,CAACoB,cAAc,EAAE;MACpB,OAAOzB,MAAM;;IAEd,IAAIyB,cAAc,CAAC5B,IAAI,EAAE;MACxB2B,KAAK,GAAG,CAAC;MACT;;IAED,IAAIxB,MAAM,GAAGuB,IAAI,EAAE;IACnB,IAAIvB,MAAM,IAAIA,MAAM,CAACH,IAAI,EAAE;MAC1B,IAAIgB,cAAc,CAACb,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACE,CAAC;OACjB,MAAM;QACNsB,KAAK,GAAG,CAAC;QACT;;;IAGF,IAAIF,MAAM,EAAE;MACX,IAAII,WAAW,GAAGJ,MAAM,EAAE;MAC1B,IAAII,WAAW,IAAIA,WAAW,CAAC7B,IAAI,IAAI,CAACgB,cAAc,CAACa,WAAW,CAAC,EAAE;QACpEF,KAAK,GAAG,CAAC;QACT;;;;EAIH,IAAId,IAAI,GAAG,IAAIf,KAAK,EAAE;EACtB,IAAIgC,MAAM,GAAGvB,OAAO,CAACO,IAAI,CAAC,IAAI,EAAED,IAAI,EAAE,CAAC,CAAC;EACxC,CAACc,KAAK,KAAK,CAAC,GAAGC,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,GAAGJ,KAAK,KAAK,CAAC,GAAGxB,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,GAAGH,WAAW,CAAC7B,IAAI,CAACiC,kBAAkB,CAAC,EAAEjC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;EAC/J,OAAOjB,IAAI;EACX,SAASmB,gBAAgB,CAACpB,KAAK,EAAE;IAChCT,MAAM,GAAGS,KAAK;IACd,GAAG;MACF,IAAIa,MAAM,EAAE;QACXI,WAAW,GAAGJ,MAAM,EAAE;QACtB,IAAII,WAAW,IAAIA,WAAW,CAAC7B,IAAI,IAAI,CAACgB,cAAc,CAACa,WAAW,CAAC,EAAE;UACpEA,WAAW,CAAC7B,IAAI,CAACiC,kBAAkB,CAAC,CAACjC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;UACzD;;;MAGFF,cAAc,GAAGJ,IAAI,EAAE;MACvB,IAAI,CAACI,cAAc,IAAKZ,cAAc,CAACY,cAAc,CAAC,IAAI,CAACA,cAAc,CAACpB,CAAE,EAAE;QAC7ED,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;QACxB;;MAED,IAAIyB,cAAc,CAAC5B,IAAI,EAAE;QACxB4B,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,CAAC/B,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;QAC1D;;MAED3B,MAAM,GAAGuB,IAAI,EAAE;MACf,IAAIV,cAAc,CAACb,MAAM,CAAC,EAAE;QAC3BA,MAAM,GAAGA,MAAM,CAACK,CAAC;;KAElB,QAAQ,CAACL,MAAM,IAAI,CAACA,MAAM,CAACH,IAAI;IAChCG,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,CAAChC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;;EAEnD,SAASC,gBAAgB,CAACH,cAAc,EAAE;IACzC,IAAIA,cAAc,EAAE;MACnBzB,MAAM,GAAGuB,IAAI,EAAE;MACf,IAAIvB,MAAM,IAAIA,MAAM,CAACH,IAAI,EAAE;QAC1BG,MAAM,CAACH,IAAI,CAACgC,gBAAgB,CAAC,CAAChC,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;OAClD,MAAM;QACNE,gBAAgB,CAAC7B,MAAM,CAAC;;KAEzB,MAAM;MACNI,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;;;EAG1B,SAAS8B,kBAAkB,GAAG;IAC7B,IAAIL,cAAc,GAAGJ,IAAI,EAAE,EAAE;MAC5B,IAAII,cAAc,CAAC5B,IAAI,EAAE;QACxB4B,cAAc,CAAC5B,IAAI,CAAC+B,gBAAgB,CAAC,CAAC/B,IAAI,CAAC,KAAK,CAAC,EAAE8B,MAAM,CAAC;OAC1D,MAAM;QACNC,gBAAgB,CAACH,cAAc,CAAC;;KAEjC,MAAM;MACNrB,OAAO,CAACM,IAAI,EAAE,CAAC,EAAEV,MAAM,CAAC;;;AAG3B;;MC9Ua+B,cAAe,SAAQC,eAAe;EAI/CC,YAAYC,GAAQ,EAAEC,OAAe,EAAEC,GAA6B,EAAEC,OAAoB;IACxF,KAAK,CAACD,GAAG,EAAEC,OAAO,CAAC;IACnB,IAAI,CAACC,QAAQ,GAAGH,OAAO;IACvB,IAAI,CAACI,IAAI,GAAGL,GAAG;;EAGjBM,SAAS,CAACC,cAAgC;IACxC,IAAMC,aAAa,GAAGD,cAAc,GAAGA,cAAc,GAAG,IAAI,CAACH,QAAQ;IACrE,IAAMK,MAAM,GAAG,KAAK,CAACH,SAAS,CAACE,aAAa,CAAC;IAC7C,IAAME,QAAQ,GAAG,IAAI;IAErB,IAAMC,QAAQ,GAAG;MACfC,GAAG,CAACC,MAAW,EAAEC,IAAS,EAAEC,QAAa;QACvC,IAAID,IAAI,KAAK,iBAAiB,EAAE;UAC9B,IAAMvC,KAAK,GAAGsC,MAAM,CAACC,IAAI,CAAC;UAC1B,IAAIvC,KAAK,YAAYyC,QAAQ,EAAE;YAC7B,OAAO;gDAAaC,IAAS;gBAATA,IAAS;;cAC3B,IAAMC,GAAG,GAAGD,IAAI,CAACE,IAAI,GAAGF,IAAI,GAAGA,IAAI,CAAC,CAAC,CAAC;cACtC,IAAMG,QAAQ,GAAGF,GAAG,CAAC3C,KAAK,GAAG2C,GAAG,CAAC3C,KAAK,CAAC8C,QAAQ,EAAE,GAAG,GAAG;cAEvDX,QAAQ,CAACL,IAAI,CAACiB,mBAAmB,CAACJ,GAAG,CAACK,EAAE,EAAEH,QAAQ,EAAEF,GAAG,CAACC,IAAI,CAAC;cAE7D,OAAO,IAAIK,OAAO,CAAC,CAACC,OAAO,EAAEhC,MAAM;gBACjCiB,QAAQ,CAACL,IAAI,CAACqB,SAAS,WAAQP,IAAS;kBAAA;;sBActC,IAAMQ,QAAQ,GAAGjB,QAAQ,CAACkB,gBAAgB,CAACC,SAAwB,EAAEC,IAAI,CAAC;sBAC1EH,QAAQ,CAACR,IAAI,GAAGD,GAAG,CAACC,IAAI;sBACxB,OAAOM,OAAO,CAACE,QAAQ,CAAC;;oBAfxB,IAAMG,IAAI,GAAGX,IAAI,CAACW,IAAI;;oBAGtB,IAAID,SAAS,GAAG,IAAI;oBACpB,IAAIE,MAAM,GAAG,CAAC;oBAAA;sBAAA,OACPF,SAAS,KAAK,IAAI,IAAIE,MAAM,GAAG,CAAC;2CAAE;sBAAA,uBACrBrB,QAAQ,CAACsB,cAAc,CAACF,IAAI,CAAC;wBAA/CD,SAAS,wBAAsC;wBAAA;0BAAA,IAC3CA,SAAS,KAAK,IAAI;4BAAA,uBACd,IAAIL,OAAO,CAAES,CAAC,IAAKC,UAAU,CAACD,CAAC,EAAE,IAAI,CAAC,CAAC;8BAC7CF,MAAM,EAAE;;;;wBAAA;;qBAEX;oBAAA;mBAKF;oBAAA;;kBAAC;gBACFrB,QAAQ,CAACL,IAAI,CAAC8B,aAAa,CAAC;kBAC1B1C,MAAM,CAAC;oBAAE2C,IAAI,EAAE;mBAAM,CAAC;iBACvB,CAAC;eACH,CAAC;aACH;;;QAIL,IAAItB,IAAI,KAAK,kBAAkB,EAAE;UAC/B,IAAMvC,MAAK,GAAGsC,MAAM,CAACC,IAAI,CAAC;UAC1B,IAAIvC,MAAK,YAAYyC,QAAQ,EAAE;YAC7B,OAAO;cACL,OAAO,IAAIqB,KAAK,CAAC5B,MAAM,EAAEE,QAAQ,CAAC;aACnC;;;QAIL,IAAIG,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,oBAAoB,IAAIA,IAAI,KAAK,gBAAgB,EAAE;UACxF,IAAMvC,OAAK,GAAGsC,MAAM,CAACC,IAAI,CAAC;UAC1B,IAAIvC,OAAK,YAAYyC,QAAQ,EAAE;YAC7B,OAAO;cACL,IAAMsB,IAAI,GACRxB,IAAI,KAAK,aAAa,GAClB,eAAe,GACfA,IAAI,KAAK,oBAAoB,GAC7B,UAAU,GACV,sBAAsB;cAAA,mCANVG,IAAS;gBAATA,IAAS;;cAO3B,OAAOP,QAAQ,CAAC6B,aAAa,CAACD,IAAI,EAAErB,IAAI,CAAC;aAC1C;;;QAIL,OAAOuB,OAAO,CAAC5B,GAAG,CAACC,MAAM,EAAEC,IAAI,EAAEC,QAAQ,CAAC;;KAE7C;IAED,OAAO,IAAIsB,KAAK,CAAC5B,MAAM,EAAEE,QAAQ,CAAC;;EAGpC4B,aAAa,CAACD,IAAY,EAAErB,IAAS;IACnC,IAAMwB,OAAO,GAAGxB,IAAI,CAACyB,MAAM,KAAK,CAAC,GAAGzB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI;IAClD,IAAI,CAACZ,IAAI,CAACsC,eAAe,CAACL,IAAI,EAAEG,OAAO,CAAC;IAExC,OAAO,IAAIjB,OAAO,CAAC,CAACC,OAAO,EAAEhC,MAAM;MACjC,IAAI,CAACY,IAAI,CAACuC,SAAS,CAAC;QAClB,OAAOnB,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC,CAAC;OACxB,CAAC;MACF,IAAI,CAACZ,IAAI,CAACwC,aAAa,CAAC;QACtBpD,MAAM,CAAC;UAAE2C,IAAI,EAAE;SAAM,CAAC;OACvB,CAAC;KACH,CAAC;;;;MChGKU,eAAgB,SAAQC,SAAS;EAG1ChD,YAAYiD,OAAgB,EAAEC,OAAY,EAAEC,OAAgC;IACxE,KAAK,CAACF,OAAO,EAAEE,OAAO,CAAC;IACvB,IAAI,CAAC7C,IAAI,GAAG,IAAI8C,cAAc,CAACF,OAAO,CAAC;;EAG3CG,QAAQ,CAACC,SAAc;IACnB,IAAI,CAACL,OAAO,CAACM,eAAe,EAAE;IAC9B,IAAI,CAACjD,IAAI,CAACkD,SAAS,CAACF,SAAS,CAAC;IAE9B,OAAO,IAAI7B,OAAO,CAAC,CAACC,OAAO,EAAEhC,MAAM;MAC/B,IAAI,CAACY,IAAI,CAACmD,iBAAiB,CAAErC,IAAS;QACtC,IAAMsC,aAAa,GAAGJ,SAAS,GAAGK,QAAQ,CAACL,SAAS,CAACM,OAAO,CAAC,GAAGD,QAAQ,CAACvC,IAAI,CAACwC,OAAO,CAAC;QACtF,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,WAAW,CAAC1C,IAAI,CAAClB,OAAO,EAAEkB,IAAI,CAAC2C,WAAW,CAAC;QACtE,IAAI,CAACd,OAAO,CAAC5D,MAAM,CAAC;UAAEuE,OAAO,EAAEF,aAAa;UAAEM,QAAQ,EAAE,CAAC5C,IAAI,CAAClB,OAAO;SAAG,CAAC;QACzEwB,OAAO,EAAE;OACR,CAAC;MACF,IAAI,CAACpB,IAAI,CAAC2D,cAAc,CAAE7C,IAAS;QACnC,IAAMsC,aAAa,GAAGJ,SAAS,GAAGK,QAAQ,CAACL,SAAS,CAACM,OAAO,CAAC,GAAGD,QAAQ,CAACvC,IAAI,CAACwC,OAAO,CAAC;QACtF,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,WAAW,CAAC1C,IAAI,CAAClB,OAAO,EAAEkB,IAAI,CAAC2C,WAAW,CAAC;QACtE,IAAI,CAACd,OAAO,CAAC5D,MAAM,CAAC;UAAEuE,OAAO,EAAEF,aAAa;UAAEM,QAAQ,EAAE,CAAC5C,IAAI,CAAClB,OAAO;SAAG,CAAC;QACzEwB,OAAO,EAAE;OACR,CAAC;MACF,IAAI,CAACpB,IAAI,CAAC4D,qBAAqB,CAAE9C,IAAS;QAC1C,IAAMsC,aAAa,GAAGJ,SAAS,GAAGA,SAAS,CAACM,OAAO,GAAGxC,IAAI,CAACwC,OAAO;QAClE,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,WAAW,CAAC1C,IAAI,CAAClB,OAAO,EAAEkB,IAAI,CAAC2C,WAAW,CAAC;QACtE,IAAI,CAACd,OAAO,CAAC5D,MAAM,CAAC;UAAEuE,OAAO,EAAEF,aAAa;UAAEM,QAAQ,EAAE,CAAC5C,IAAI,CAAClB,OAAO;SAAG,CAAC;QACzEwB,OAAO,EAAE;OACR,CAAC;MACF,IAAI,CAACpB,IAAI,CAAC6D,gBAAgB,CAAE/C,IAAS;QACrC,IAAMsC,aAAa,GAAGC,QAAQ,CAACvC,IAAI,CAACwC,OAAO,CAAC;QAC5C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACC,WAAW,CAAC1C,IAAI,CAAClB,OAAO,EAAEkB,IAAI,CAAC2C,WAAW,CAAC;QACtE,IAAI,CAACd,OAAO,CAAC5D,MAAM,CAAC;UAAEuE,OAAO,EAAEF,aAAa;UAAEM,QAAQ,EAAE,CAAC5C,IAAI,CAAClB,OAAO;SAAG,CAAC;QACzER,MAAM,CAAC;UAAE2C,IAAI,EAAE,IAAI;UAAEK,OAAO,EAAE;SAA8B,CAAC;OAC5D,CAAC;KACL,CAAC;;EAGN0B,UAAU;IACN,IAAI,CAAC9D,IAAI,CAAC+D,UAAU,EAAE;IAEtB,OAAO,IAAI5C,OAAO,CAAEC,OAAO;MACvB,IAAI,CAACpB,IAAI,CAACgE,eAAe,CAAC;QAC1B,IAAI,CAACT,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACZ,OAAO,CAACsB,UAAU,EAAE;QACzB7C,OAAO,EAAE;OACR,CAAC;KACL,CAAC;;EAGNoC,WAAW,CAAC5D,OAAe,EAAE6D,WAAmB;IAC5C,OAAO,IAAIjE,cAAc,CAAC,IAAI,CAACQ,IAAI,EAAEJ,OAAO,EAAE6D,WAAW,CAAC;;;;;;"}